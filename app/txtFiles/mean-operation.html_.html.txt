
AlloyDB - Database of Databases
Database of Databases
Browse
Leaderboards
Recent
Revision List
Accounts
Login
AlloyDB
AlloyDB is a fully-managed database system that is a fork from PostgreSQL created by Google Cloud. AlloyDB separates the database layer from the storage layer. The disaggregated storage layer first handles write operations by writing the write-ahead log (WAL) to storage. A log processing service (LPS) then processes these WAL records and generates database blocks. The storage layer can be independently sharded and replicated for durability due to its disaggregated nature. For read operations, the read query can be processed either by the primary instance or a replica instance, which can be independently scaled. Results are returned if the data block is in the instance’s memory cache. If not, a fetch request is sent to the storage layer. AlloyDB further extends the caching capacity of the read instance by using local SSD as cache as well. 
AlloyDB also uses an automatic adaptive columnar engine, memory management, and vacuum. The adaptive columnar engine utilizes a machine learning approach to determine the optimal data storage format for the workload and applies potential optimizations for query processing. Additionally, AlloyDB employs automatically adjusted memory management and vacuum techniques.
In addition, AlloyDB announced an edition AlloyDB Omni which containerizes the AlloyDB database engine to be deployed in Linux environments.
https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage
Checkpoints
Non-Blocking
In AlloyDB, WAL records are written to the storage layer synchronously by the primary database instance. Then, the log processing service in the storage layer is responsible for replaying the logs continuously. AlloyDB supports checkpoints but there is no need for flushing the changes in the database layer to the storage layer.
https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage
Concurrency Control
Multi-version Concurrency Control (MVCC)
Two-Phase Locking (Deadlock Detection)
AlloyDB supports MVCC and Two-Phase Locking.
https://www.postgresql.org/docs/7.1/mvcc.html
https://www.interdb.jp/pg/pgsql05.html
Data Model
Object-Relational
AlloyDB is an object-relational database.
https://www.postgresql.org/docs/current/intro-whatis.html
Foreign Keys
Supported
AlloyDB supports foreign keys
https://www.postgresql.org/docs/current/tutorial-fk.html
Indexes
Hash Table
Bw-Tree
Inverted Index (Full Text)
Block Range Index (BRIN)
AlloyDB provides the same index types as PostgreSQL: B-tree, Hash, GIST, SP-GIST, GIN and BRIN index types.
https://www.postgresql.org/docs/current/indexes-types.html#INDEXES-TYPE-GIST
Isolation Levels
Read Uncommitted
Read Committed
Serializable
Repeatable Read
Isolation level in AlloyDB can be set through the configuration flag "default_transaction_isolation", where it can be set to either “read uncommitted”, “read committed”, “repeatable read”, or “serializable”. By default, the isolation level is set to "read committed".
https://cloud.google.com/alloydb/docs/reference/database-flags
Joins
Nested Loop Join
Hash Join
Sort-Merge Join
Index Nested Loop Join
AlloyDB supports the following three join strategies: nested loop join and it is possible to utilize the values from the row of the left relation as keys for scanning the right relation's index given that the right relation can be processed with index scan, merge join and hash join.
https://www.postgresql.org/docs/current/planner-optimizer.html
Logging
Physical Logging
AlloyDB uses the same logging format as PostgreSQL, which uses physical logging
https://www.interdb.jp/pg/pgsql09.html
Parallel Execution
Intra-Operator (Horizontal)
Inter-Operator (Vertical)
AlloyDB supports both inter-operation parallelism, allowing for parallel execution of parts of the plan, and intraoperator parallelism, enabling partitioning and sharing of specific operators such as scans, joins, aggregation, and append across multiple processes.
https://www.postgresql.org/docs/current/how-parallel-query-works.html
https://www.postgresql.org/docs/current/parallel-plans.html#PARALLEL-SCANS
Query Compilation
Not Supported
AlloyDB does not support code generation or JIT optimization.
Query Execution
Tuple-at-a-Time Model
Vectorized Model
The columnar engine of AlloyDB uses a vectorized model where SIMD instructions are used when deemed suitable. Bloom filters are also used for optimization purposes, depending on the selectivity of the workload. The row-based engine uses the traditional postgreSQL execution node with Tuple-at-a-Time model.
https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-columnar-engine
Query Interface
SQL
Stored Procedures
AlloyDB supports SQL and Stored Procedures. Additional REST API and CLI tools are available for managing the database system resources including Google Cloud projects, project backups, clusters, cluster instances, etc.
https://www.postgresql.org/docs/current/sql-createprocedure.html
Storage Architecture
Disk-oriented
For AlloyDB, all the WAL records are written synchronously to the storage layer, where the records get processed by the log processing service.
https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage
Storage Model
Decomposition Storage Model (Columnar)
N-ary Storage Model (Row/Record)
AlloyDB stores the data in the storage layer following the same format as PostgreSQL. However, a columnar engine is used where the data that gets loaded into memory can take on either the row-based format or the columnar format based on the workload, which is decided using machine learning models. As a result, query optimizations relating to columnar formats can be applied to the relevant data.
https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-columnar-engine
Storage Organization
Heaps
PostgreSQL uses heap files to store the database data. For AlloyDB, after the log processing service processes the WAL records, the resulting database blocks get sent back to the primary and replica instances from the storage layer.
https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage
https://rachbelaid.com/introduction-to-postgres-physical-storage/
Stored Procedures
Supported
AlloyDB supports stored procedures. SQL, PL/pgSQL, and C are supported by default. In addition, extensions to PL/proxy and PL/v8 can be added to support additional procedural languages.
https://www.postgresql.org/docs/current/sql-createprocedure.html
https://cloud.google.com/alloydb/docs/reference/extensions
System Architecture
Shared-Disk
AlloyDB disaggregates its database layer and its storage layer. As a result, each component of the database system becomes more elastic to scale. AlloyDB refers to the main unit of resource as a cluster, which consists of one primary instance and multiple read pool instances. The primary instance handles read/write requests while the read pool instances only have read access. The storage layer is shared between all cluster resources.
https://cloud.google.com/blog/products/databases/alloydb-for-postgresql-intelligent-scalable-storage
Views
Virtual Views
Materialized Views
AlloyDB follows the same rule as PostgreSQL where both Materialized Views and Virtual Views are supported.
https://www.postgresql.org/docs/current/rules-materializedviews.html
https://www.postgresql.org/docs/current/sql-createview.html
Revision #13
&nbsp;|&nbsp;
Updated 04/30/2023 8:16 p.m.
People Also Viewed
Website
https://cloud.google.com/alloydb
Tech Docs
https://cloud.google.com/alloydb/docs/
Developer
Google
Country of Origin
US
Start Year
2022
Project Type
Commercial
Derived From
PostgreSQL
Compatible With
PostgreSQL
Operating Systems
Hosted
Licenses
Proprietary
Revision #13
&nbsp;|&nbsp;
Updated 04/30/2023 8:16 p.m.
People Also Viewed
Copyright &copy; 2023
&bullet;
Carnegie Mellon Database Group
 Contact
 Github
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-4067813-21');
    function convertToSlug(text) {
        return text
            .toLowerCase()
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[^\w -]+/g,'')
            .replace(/ +/g,'-');
    }
    // Top Search Box
    $("#topsearch").find('input[name="q"]').autoComplete({
        minChars: 3,
        source: function(term, response) {
            $.getJSON('/search/autocomplete/', { q: term }, function(data) { response(data); });
        },
        onSelect: function(e, term, item) { window.location.href = "/db/" + convertToSlug(term); }
    });
