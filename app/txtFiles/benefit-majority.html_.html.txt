
QuestDB - Database of Databases
Database of Databases
Browse
Leaderboards
Recent
Revision List
Accounts
Login
QuestDB
QuestDB is an open-source time-series relational database. It uses a column-oriented approach and supports heavy parallelized vectorized execution using SIMD instructions. QuestDB implements a SQL interface and augments it with extensions simplifying the semantics of time-series queries. It supports high-throughput, schema-agnostic ingestion using the Postgres wire protocol and the InfluxDB line protocol. QuestDB is written from scratch in Java and C++ with no external dependencies and zero garbage collection.
History
QuestDB started as a side project in 2014 by Vlad Ilyushchenko who applied principles from low latency techniques found in the financial services industry. QuestDB is backed by YCombinator.
https://github.com/bluestreak01/questdb/commit/95b8095427c4e2c7814ad56d06b5fc65f6685130
https://news.ycombinator.com/item?id=23975807
Concurrency Control
Timestamp Ordering
QuestDB uses a single writer model. The writer re-orders timestamps on the fly.
Multi-publisher, single consumer queue provides concurrent write access.
https://questdb.io/docs/concept/storage-model#summary
Data Model
Relational
QuestDB uses a relational model with column-based storage model.
https://questdb.io/docs/concept/storage-model
Foreign Keys
Not Supported
Hardware Acceleration
Custom
SIMD optimised analytics.
Indexes
Hash Table
Indexing is available for symbol columns. The symbol datatype in QuestDB is used to store repeatitive strings. Internally, it is stored as a dictionary of integers and corresponding string values. The Index support for other types will be added over time.
https://questdb.io/docs/concept/indexes
Isolation Levels
Read Committed
QuestDB uses the READ COMMITTED isolation level.
https://github.com/questdb/questdb/blob/99e1809058c8daff3acce38f5585215a8590e071/core/src/main/java/io/questdb/griffin/engine/functions/catalogue/ShowTransactionIsolationLevelCursorFactory.java#L38
Joins
Nested Loop Join
Hash Join
Semi Join
QuestDB supports INNER, LEFT OUTER, and CROSS join types. FULL joins are not yet implemented and are on our roadmap. In addition, QuestDB also supports ASOF, LT, and SPLICE join types particularly useful for time-series analytics. 
Joins in QuestDB are internally implemented as nested loop joins and hash joins.
https://questdb.io/docs/reference/sql/join/
Logging
Physical Logging
Starting from version 7.0, QuestDB supported using WAL to ingest data. With the addition of WAL-supported tables, clients can write to disk independently without holding the lock of the table writer. Transaction numbers are provided by a central sequencer protecting a single source of truth. After applying the WALs, the data is applied to the table asynchronously by another job.
https://github.com/questdb/questdb/pull/2144
Parallel Execution
Intra-Operator (Horizontal)
Multi threaded SQL execution
Query Compilation
JIT Compilation
QuestDB uses a JIT compiler to improve performance by compiling the predicate evaluation part of the query. After determining whether a filter is suitable for compilation, the compiler frontend would transform the abstract syntax tree (AST) of the filter into an intermediate representation (IR). The IR is then processed by the compiler backend to emit vectorized machine code with the AVX2 instruction set.
https://questdb.io/docs/concept/jit-compiler
https://questdb.io/blog/2022/01/12/jit-sql-compiler
Query Execution
Vectorized Model
QuestDB uses the vectorized execution model and takes advantage of SIMD operations for fast aggregations and predicate evaluation.
https://questdb.io/blog/2020/04/02/using-simd-to-aggregate-billions-of-rows-per-second
Query Interface
SQL
QuestDB has a SQL interface mostly compatible with the PostgreSQL dialect. It also extends the standard SQL with constructs simplifying the semantics of time-series queries (e.g. LATEST ON, SAMPLE BY). It supports a simple REST API, the Postgres wire protocol, as well as the InfluxDB line protocol (ILP). QuestDB now has an ILP client library in the following languages: .Net, C, C++, Go, Java, JavaScript, Python, and Rust. It is compatible with other third-party tools including Flink, Grafana, Kafka, MindsDB, Pandas, Prometheus, Redpanda, and Telegraf.
https://questdb.io/docs/concept/sql-execution-order/
https://questdb.io/docs/concept/sql-extensions/
Storage Architecture
Disk-oriented
QuestDB uses a disk-oriented storage architecture with memory-mapped file data access.
https://questdb.io/docs/concept/storage-model#acid-properties
Storage Model
Decomposition Storage Model (Columnar)
QuestDB uses a column-based storage model. Data is stored in tables with each column stored in its own file and its own native format. New data is appended to the bottom of each column to allow data to be organically retrieved in the same order that it was ingested.
https://questdb.io/docs/concept/storage-model
Storage Organization
Log-structured
Stored Procedures
Not Supported
System Architecture
Shared-Nothing
Embedded
Views
Not Supported
Revision #25
&nbsp;|&nbsp;
Updated 04/02/2023 3:30 a.m.
People Also Viewed
Website
https://www.questdb.io/
Source Code
https://github.com/questdb/questdb
Tech Docs
https://questdb.io/docs/introduction/
Twitter
   @QuestDb
Developer
QuestDB
Country of Origin
GB
Start Year
2014
https://github.com/bluestreak01/questdb/commit/95b8095427c4e2c7814ad56d06b5fc65f6685130
Project Type
Commercial, Open Source
Written in
C++, Java
Supported languages
C, C++, Go, Java, JavaScript, Python, R, Rust, SQL
Inspired By
Kdb+
Compatible With
InfluxDB, PostgreSQL, Prometheus
Operating Systems
Android, Linux, OS X, Windows
Licenses
Apache v2
Revision #25
&nbsp;|&nbsp;
Updated 04/02/2023 3:30 a.m.
People Also Viewed
Copyright &copy; 2023
&bullet;
Carnegie Mellon Database Group
 Contact
 Github
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-4067813-21');
    function convertToSlug(text) {
        return text
            .toLowerCase()
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[^\w -]+/g,'')
            .replace(/ +/g,'-');
    }
    // Top Search Box
    $("#topsearch").find('input[name="q"]').autoComplete({
        minChars: 3,
        source: function(term, response) {
            $.getJSON('/search/autocomplete/', { q: term }, function(data) { response(data); });
        },
        onSelect: function(e, term, item) { window.location.href = "/db/" + convertToSlug(term); }
    });
